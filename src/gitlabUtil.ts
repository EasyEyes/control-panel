import { Buffer } from "buffer";

// ----------------------------------------------------------------
//                      Data Types / Interfaces
// ----------------------------------------------------------------
export interface ICommitAction {
  action: "create" | "delete" | "move" | "update" | "chmod";
  file_path: string;
  content: string;
  previous_path?: string;
  encoding?: "text" | "base64";
  last_commit_id?: string;
  execute_filemode?: boolean;
}

export interface Repository {
  id: string;
}

export interface Experiment {
  participantRecruitmentServiceName: string;
  participantRecruitmentServiceUrl: string;
  participantRecruitmentServiceCode: string;
  experimentUrl: string;
}

export class GitlabUser {
  public id: string = "";
  public username: string = "";
  public name: string = "";

  public projectList: any[] = [];

  constructor(public accessToken: string) {}

  async initUserDetails(): Promise<void> {
    const response = await fetch(
      `https://gitlab.pavlovia.org/api/v4/user?access_token=${this.accessToken}`
    );
    const responseBody = await response.json();
    this.id = responseBody.id;
    this.username = responseBody.username;
    this.name = responseBody.name;
  }

  async initProjectList(): Promise<void> {
    this.projectList = await getAllProjects(this);
  }
}

/**
 * @param filePath absolute file path in repository
 * @returns URL-encoded string of given filePath
 */
export const encodeGitlabFilePath = (filePath: string): string => {
  let res: string = "";
  for (let i = 0; i < filePath.length; i++) {
    let c = filePath[i];
    if (c == "/") c = "%2F";
    else if (c == ".") c = "%2E";
    res = res + c;
  }

  return res;
};

// ----------------------------------------------------------------
//                      Functions
// ----------------------------------------------------------------

export const getTextFileDataFromGitLab = (
  repoID: number,
  filePath: string,
  accessToken: string
): Promise<string> => {
  return new Promise<string>(async (resolve) => {
    const headers: Headers = new Headers();
    headers.append("Authorization", `bearer ${accessToken}`);
    headers.append("Content-Type", "text/plain"); // useless?

    const requestOptions: any = {
      method: "GET",
      headers: headers,
      redirect: "follow",
    };

    const response = await fetch(
      `https://gitlab.pavlovia.org/api/v4/projects/${repoID}/repository/files/${encodeGitlabFilePath(
        filePath
      )}/?ref=master`,
      requestOptions
    )
      .then((response) => {
        // ? It seems that it also works for text files?
        return response.text();
      })
      .then((result) => {
        return result;
      })
      .catch((error) => {
        return error;
      });

    const content = JSON.parse(response).content;
    const decodedContent = Buffer.from(content, "base64").toString("utf8");
    resolve(decodedContent);
  });
};

/**
 * @param repoID unique ID of repository auto-generated by Gitlab API
 * @param filePath absolute file path in repository
 * @param accessToken authorization header token for
 * @returns requested file content from given repository in base64 format
 */
export const getBase64FileDataFromGitLab = (
  repoID: number,
  filePath: string,
  accessToken: string
): Promise<string> => {
  return new Promise<string>(async (resolve) => {
    // Create auth header
    const headers: Headers = new Headers();
    headers.append("Authorization", `bearer ${accessToken}`);

    // Create Gitlab API request options
    const requestOptions: any = {
      method: "GET",
      headers: headers,
      redirect: "follow",
    };

    // Convert given filepath to URL-encoded string
    const encodedFilePath = encodeGitlabFilePath(filePath);

    // Make API call to fetch data
    const response = await fetch(
      `https://gitlab.pavlovia.org/api/v4/projects/${repoID}/repository/files/${encodedFilePath}/?ref=master`,
      requestOptions
    )
      .then((response) => {
        // ? It seems that it also works for text files?
        return response.text();
      })
      .then((result) => {
        return result;
      })
      .catch((error) => {
        return error;
      });

    resolve(JSON.parse(response).content);
  });
};

/**
 * makes given commits to Gitlab repository
 * @param user commits are on behalf of this userFont
 * @param repo commits is pushed to this repository
 * @param commits list of commit actions
 * @param commitMessage message
 * @param branch commits are pushed to this branch of repo
 * @returns response from API call made to push commits
 */
export const pushCommits = async (
  user: GitlabUser,
  repo: Repository,
  commits: ICommitAction[],
  commitMessage: string,
  branch: string
): Promise<any> => {
  const commitBody = {
    branch,
    commit_message: commitMessage,
    actions: commits,
  };

  const response = await fetch(
    `https://gitlab.pavlovia.org/api/v4/projects/${repo.id}/repository/commits?access_token=${user.accessToken}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(commitBody),
    }
  ).then(async (response) => {
    if (!response.ok) {
      alert(
        "Uploading Failed. Please try again. We are working on providing more detailed error messages."
      );
      location.reload();
    }
    return response.json();
  });

  return await response;
};

/**
 * @param user queried users
 * @returns returns list of all gitlab projects created by user
 */
export const getAllProjects = async (user: GitlabUser) => {
  const projectList: any[] = [];

  // get first page separately to fetch page count
  const firstResponse = await fetch(
    `https://gitlab.pavlovia.org/api/v4/users/${user.id}/projects?access_token=${user.accessToken}&per_page=100`
  );
  const firstResponseData = await firstResponse.json();
  projectList.push(...firstResponseData);

  // check if header is present
  const pageCountHeader = await firstResponse.headers.get("x-total-pages");
  if (!pageCountHeader) {
    throw new Error(
      "x-total-pages header is missing. Gitlab API probably updated."
    );
  }

  // get remaining pages
  const pageCount = parseInt(pageCountHeader);
  const pageList: Promise<any>[] = [];
  for (let curPage = 2; curPage <= pageCount; curPage++) {
    const paginationResponse = fetch(
      `https://gitlab.pavlovia.org/api/v4/users/${user.id}/projects?access_token=${user.accessToken}&page=${curPage}&per_page=100`
    );
    pageList.push(paginationResponse);
  }

  const paginationResponseList = await Promise.all(pageList);
  for (let idx = 0; idx < paginationResponseList.length; idx++) {
    const ithResponseData = await paginationResponseList[idx].json();
    projectList.push(...ithResponseData);
  }

  return projectList;
};

/**
 * @param projectList list of projects returned by gitlab API
 * @param keyProjectName project name to search for
 * @returns true if keyProjectName exists in given project list
 */
export const isProjectNameExistInProjectList = (
  projectList: any[],
  keyProjectName: string
): boolean => {
  return projectList
    .map((i: any) => {
      return i ? i.name : "null";
    })
    .includes(keyProjectName);
};

/**
 * @param projectList list of projects returned by gitlab API
 * @param keyProjectName project name to search for
 * @returns project with given project name
 */
export const getProjectByNameInProjectList = (
  projectList: any[],
  keyProjectName: string
): any => {
  return projectList.find((i: any) => i.name == keyProjectName);
};

/**
 * creates a new project with given project name on Gitlab
 * @param repoName new project or repository name
 * @param gitlabUser project will be created on behalf of this userFont
 * @returns API response
 */
export const createEmptyRepo = async (
  repoName: string,
  user: GitlabUser
): Promise<any> => {
  const newRepo = await fetch(
    "https://gitlab.pavlovia.org/api/v4/projects?name=" +
      repoName +
      "&access_token=" +
      user.accessToken,
    {
      method: "POST",
    }
  )
    .then((response) => {
      return response.json();
    })
    .catch((error) => {
      alert("Error uploading. Please try again");
      location.reload();
    });

  return await newRepo;
};

export const runExperiment = async (
  user: GitlabUser,
  newRepo: Repository,
  currentExperiment: Experiment
) => {
  const running = await fetch(
    "https://pavlovia.org/api/v2/experiments/" + newRepo.id + "/status",
    {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        oauthToken: user.accessToken,
      },

      body: JSON.stringify({
        newStatus: "RUNNING",
        recruitment: {
          policy: { type: "URL", url: currentExperiment.experimentUrl },
        },
      }),
    }
  );
  return await running.json();
};

/* -------------------------------------------------------------------------- */

export const commitMessages = {
  newResourcesUploaded: "‚ö° new EasyEyes resources",
  resourcesTransferred: "üì¶ load EasyEyes resources from resources repo",
  thresholdCoreFileUploaded: "üîÆ create threshold core components",
  addExperimentFile: "üñºÔ∏è add experiment file",
};

export const defaultBranch = "master";
